# -*- coding: utf-8 -*-
"""CDualPBigM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KGGuJxNsGIWTf6qRUJf0NurU-GgozDys

Grupo:
1. Lorena Yaneth Pérez 20200396
2. Mario Pisquiy 20200399
"""

#importando librerias

from tabulate import tabulate
from numpy.matrixlib.defmatrix import matrix
import numpy as np
import pandas as pd
import math as mt

"""Ejemplo de un formato en txt: 
</br>
2,3,6,1,30</br>
1,2,3,1,40</br>
6,2,0,-1,2</br>
4,0,1,-1,5</br>
4,5,2,0,0</br>
</br>
Este formato tiene 3 variables y 4 restricciones.
1. Las primeras 3 filas representas las restriciones. Las primeras 3 columnas son representan las variables 
de las restricciones, la penúltima es el signo y la última es el resultado.
2. Las última fila es la funcion de optimización (Z), los primeros 3 valores (columnas) son los valores de las variables a considerar.
La penúltima y la última se quedan en cero ya que no es una restricción.
"""

def columpiv(matriz, colum, filas): #Se encuentrala columna donde está el pivote
    if decision == 1:
      pivoteZ = 1000000000000000000000
    else:
      pivoteZ = -100000000000000000000
    global colum_pivote
    for j in range(colum):
      if decision == 1:
        if matriz[filas - 1,j] < 0 and matriz[filas - 1,j] < pivoteZ: #
            pivoteZ = matriz[filas - 1,j]
            colum_pivote = j
      if decision == 2:
        if matriz[filas - 1,j] > 0 and matriz[filas - 1,j] > pivoteZ: #
            pivoteZ = matriz[filas - 1,j]
            colum_pivote = j

def pivote(matriz, colum, filas, lista): #se encuentra la fila del pivote y por lo tanto, el pivote
    global fila_pivot
    fila_pivot=0
    epivote=0
    num_menor = 1000000000000000000
    for i in range(filas - 1):
        if matriz[i,colum_pivote]==0 or matriz[i,colum - 1] / matriz[i,colum_pivote] < 0:
            continue
        else:
            if i == 0:
                if matriz[i,-1] != 0: #add   ---#tabla ? matriz
                  num_menor = matriz[i,colum - 1] / matriz[i,colum_pivote]
                  fila_pivot = i
                  epivote = matriz[i,colum_pivote] #tabla?
            elif matriz[i,colum - 1] / matriz[i,colum_pivote] < num_menor:
              if matriz[i, -1] != 0: #tabla ? matriz
                num_menor = matriz[i,colum - 1] / matriz[i,colum_pivote]
                fila_pivot = i
                epivote = matriz[i,colum_pivote]
    lista.append(fila_pivot)
    return epivote

def evaluando(tablainv,tabla, colum, epivote): #fila que se evaluara con el pivote
    for j in range(colum):
        tablainv[fila_pivot,j] = tabla[fila_pivot,j] / epivote

def inv(tablainv, tabla, colum, filas): #Se determinan los valores de la tablainv
    for i in range(filas):
        for j in range(colum):
            if i != fila_pivot:
                tablainv[i,j] = tabla[i,j]-(tabla[i,colum_pivote]*tablainv[fila_pivot,j])

#Busca negativos en la tabla
#Hasta que no queden negativos, se terminaran las iteraciones
def negativos(tablainv, colum, filas):
    negativo = None
    for j in range(colum-1):
        if tablainv[filas-1,j] < 0:
            terminar = 1
            negativo = tablainv[filas-1,j] 
        elif negativo == None:
            terminar = 0
    return terminar

#Cambiando los signos de la función de optimización
#Si todo Z es positivo, se cambia a negativo
#Si alguno de Z es negativo, se invierten signos

def cambio(decision, nZ, colum, filas, tabla):
  c=0
  for i in range(colum):
    if 0 < i <= nZ:
      if tabla[filas-1, i] > 0:
        c = c + 1
    if c > 0:
      if decision == 1:
        tabla[filas-1,i]= tabla[filas-1,i]*(-1)
      if decision == 2:
        tabla[filas-1,i]= tabla[filas-1,i]*(1)

   #cambio(decision, nZ, colum, tabla)

#Encabezado de la tabla, es para visualizar que columna corresponde con que
def encabezados(colum, nZ, nR):
  enc = []
  for i in range(colum):
    if i == 0:
      enc.append("Z")
    if i > 0  and i <= nZ:
      enc.append(f"X{i}")
    if i > nZ and i <= (nZ+nR):
      enc.append(f"S{i-nZ}")
    if i+1 == colum:

      
      enc.append(f"R")
  return enc

#encab = encabezados(colum, nZ, nR)
#print(encab)

#Si la igualdad de la restricción es negativa, se invierten signos
def igualdad(filas, tabla):
  for i in range(filas-1):
    if tabla[i, -1] < 0:
      tabla[i, :] = tabla[i, :] * -1

#igualdad(filas, tabla)

def artificial(filas, colum, nZ, tabla):
  global indicescol
  indicescol = []
  global indicesfila
  indicesfila = []
  #Se encuentran los indices en donde las columnas artificiales se deben crear
  for i in range(filas):
    for j in range(colum):
      if nZ < j < colum-1:
        if i == j - nZ-1:
          if tabla[i,j] == -1:
            if tabla[i, -1] != 0: #Si la igualdad es mayor o igual que, y su resultado es 0. No se creará la columna artificial.
              indicescol.append(j)
              indicesfila.append(i)
            else:
              tabla[i, :] =  tabla[i, :] * -1


#artificial(filas,colum, nZ, tabla)

#Añade los encabezados de las variables artificiales
def add_art_enc(filas, enc, indicescol):
  cont = 1
  for i in range(len(indicescol)):
    enc = np.insert(enc, indicescol[i], f"A{(cont)}")
    cont = cont + 1
  return enc

def add_artif(filas, tabla, indicescol, indicesfila):
  #Agregando las columnas de las variables artificiales
  listaArt = []
  for i in range(filas):
    listaArt.append(0)

  cont = 1
  for i in range(len(indicescol)):
    listaArt[indicesfila[i]] = 1
    tabla = np.insert(tabla, indicescol[i], listaArt,axis=1)
    listaArt[indicesfila[i]] = 0
    cont = cont + 1

  print(tabla)

  return tabla


#Se devuelve la solución óptima
def solucion(decision, colum, filas, tabla, enc):
  print("Solución óptima: ----> ")
  txtvar = ""
  for i in range(colum):
    cont1 = []
    cont0 = []
    indicer = 0
    for j in range(filas): #Se determina la ubicación de la solución
      if tabla[j][i] == 1.0:

        cont1.append(1)
        indicer = j
      if tabla[j][i] == 0:
        cont0.append(0)
      if len(cont0) == filas-1:
        if len(cont1) == 1:
          if i == 0:
            if decision == 1:
              print(f"\t{enc[i]} = {mt.floor(tabla[indicer,-1])}")
              txtvar += f"\t{enc[i]} = {mt.floor(tabla[indicer,-1])}\n"
            if decision == 2:
              print(f"\t{enc[i]} = {mt.floor(tabla[indicer,-1]*(-1))}")
              txtvar += f"\t{enc[i]} = {mt.floor(tabla[indicer,-1]*(-1))}\n"
          else:
            print(f"\t{enc[i]} = {mt.floor(tabla[indicer,-1])}")
            txtvar += f"\t{enc[i]} = {mt.floor(tabla[indicer,-1]*(-1))}\n"
  return txtvar



def prin(matriz, dec):
# Identificando como se desean ingresar los datos
    lectura = 2
    if lectura == 2:
    #Cargar un archivo txt con el siguiente formato
    #Las primeras 2 filas son las restricciones, la última es la función de optimización.
    #La primeras dos columnas contienen los valores de las variables, la tercera indica el signo de la igualdad y la última es resultado a lo que es igual.
    #1 2 1 4 
    #5 6 -1 8
    #7 8 0 0
        df = matriz
        #df=df.to_numpy()
        nZ = len(df[0,:]) - 2
        nR = len(df[:,0]) - 1

    filas = nR+1 #definiendo el ancho y largo de la matriz
    colum = nZ+nR+2 # nZ + nR + 2: Solo simples.   //->>> Sumar 1, columna de la variable artificial

    lista = []
    optimo = {} #guardara la iformacion que optimizara
    continuar = 1

    """Cómo se definen los signo?
    1. Si el signo es "<=", en el txt o el programa se representa como un 1.
    2. Si el signo es "=", en el txt o el programa se representa como un 1.
    3. Si el signo es ">=", en el txt o el programa se representa como un -1, indica que hay que crear una columna artificial.
    """

    #Creando la matriz de ceros
    tabla = np.zeros((filas,colum))
    tablaD = np.zeros((filas,nZ+1))
    tablaS = np.zeros((nZ+1, 1))
    tablaR = np.zeros((filas,1))
    tablaZ = np.zeros((filas,1))
    tiporest= np.zeros((filas,filas+8))
    tablaZ[-1] = 1

    #Se almacenan los indices de las filas que tienen -1, 
    #para así poder crear la columna artificial
    indicescol = []
    indicesfila = []


    if lectura == 2:
        #Se llenan los espacios de las restricciones con la info del txt
        for i in range(filas):
            for j in range(colum):
                if j == 0 and i != filas - 1: #se llena la primera columna
                    tabla[i,j] = 0 
                elif j == 0 and i == filas - 1:
                    tabla[i,j] = 1 #Valor inicial de Z

                elif 0 < j <= nZ and i != filas - 1:
                    tabla[i,j] = float(df[i,j-1]) #Valores de las restricciones
                    tablaD[i,j-1] = float(df[i,j-1])
                elif j == colum - 1 and i != filas - 1:
                    tabla[i,j] = float(df[i,-1]) #Igualado a..
                    tablaD[i,-1] = float(df[i,-1])
                elif j == colum - 1 and i == filas - 1:
                    tabla[i,j] = 0
                elif  nZ < j < colum-1:
                    if i== j - nZ-1:
                        tabla[i,j] = float(df[i, -2]) #su signo es..
                        tablaS[i,0] = float(df[i, -2])
                    else:
                        tabla[i,j] = 0

                if 0 < j <= nZ and i == filas - 1: #solicitando datos desde el txt
                    tabla[i,j] =float(df[-2, j-1]) # Valores de Z
                    tablaD[i,j-1] =float(df[-2, j-1])

                #Interesa para el problema dual
                if 0 < j <= nZ and i == filas - 1: #solicitando datos desde el txt
                    tabla[i,j] =float(df[-1, j-1]) # Valores del tipo de restriccion
                    tiporest[i,0] =float(df[-1, j-1])
                    tablaD[i,j-1] = float(df[-1, j-1]) 
                    
                elif j == colum - 1 and i == filas - 1:
                    tabla[i,j] = 0
                elif  nZ < j < colum-1:
                    if i== j - nZ-1:
                        continue
                    else:
                        tabla[i,j] = 0

    #haciendo la transpuesta
    print(tablaD)
    tablaDD = np.transpose(tablaD)
    print(tablaDD)
    tablaSS = tablaS * (-1)
    print(tablaSS)

    nZd = len(tablaDD[0,:])-1
    nRd = len(tablaDD[:,0])-1

    #insertando tabla de signos para dual
    for i in range(len(tablaD)-1):
        tablaDD = np.insert(tablaDD, len(tablaD)-1, 0, axis=1)

    for i in range(len(tablaS)):
        tablaDD[i, len(tablaD)+i-1] = tablaSS[i] 

    if ((len(tablaDD[0,:])-1)/2) > (len(tablaDD[:,0])-1 ):
        tablaDD = np.delete(tablaDD, len(tablaDD[0,:])-2, 1)

    #columna de Z para dual
    tablaDD = np.insert(tablaDD, 0, 0, axis=1)
    tablaDD[nRd,0] = 1

    filasD = nRd+1 #definiendo el ancho y largo de la matriz
    columD = nZd+nRd+2 # nZ + nR + 2: Solo simples.   //->>> Sumar 1, columna de la variable artificial

    listad = []
    optimod = {} #guardara la iformacion que optimizara
    continuard = 1

    print("Tipo de optimización: -->")
    print("(1) Maximización \t(2) Minimización ")
    global decision
    dz = pd.read_csv('B.txt', sep=" ",header=None)
    dz=dz.to_numpy()
    decision = int(dz[0,0])

    print(decision)

    #proceso del primal

    cambio(decision, nZ, colum, filas, tabla)

    enc = encabezados(colum, nZ, nR)
    print(enc)
    print(decision)

    igualdad(filas, tabla)

    artificial(filas,colum, nZ, tabla)

    tabla = add_artif(filas, tabla, indicescol, indicesfila)
    enc = add_art_enc(filas, enc, indicescol)
    colum = len(tabla[0,:])
    tablainv = np.zeros((filas,colum))
    print(enc)



    cont = 0
    #while cont < 3: #Esto solo es por pruebas, solo para visualizar las primeras 3 iteraciones..
    while continuar == 1:
        print(tabulate(tabla, headers=enc, tablefmt="fancy_grid")) #Visualizando las iteraciones de la matriz
        columpiv(tabla, colum, filas)
        epivote = pivote(tabla, colum, filas, lista)
        print(epivote) #Para poder visualizar el elemento pivote encontrado
        evaluando(tablainv, tabla, colum, epivote)
        inv(tablainv, tabla, colum, filas)
        continuar = negativos(tabla, colum, filas) #Si aún hay un negativo dentro de la matriz, se debe continuar

        for i in range(filas):
            for j in range(colum):
                tabla[i,j]=tablainv[i,j]
        for i in range(filas):
            for j in range(colum):
                tablainv[i,j]= None
        cont = cont + 1

    #continuar = iniciar(tabla, enc, tablainv, filas, colum)

    print(tabulate(tabla, headers=enc, tablefmt="fancy_grid")) #Visualizando la ultima iteracion de la matriz

    print("Solucion Problema Primal: ")
    solprimal = solucion(decision, colum, filas, tabla, enc)



    #proceso para dual
    #se invierte la decision, si es maximizacion a minimizacion y viceversa
    if decision is 1:
        decision = 2
    else:
        decision = 1

    print(tablaDD)
    print(decision)
    cambio(decision, nZd, columD, filasD, tablaDD)

    enc = encabezados(columD, nZd, nRd)
    print(enc)

    igualdad(filasD, tablaDD)

    indicescol.clear()
    indicesfila.clear()
    artificial(filasD,columD, nZd, tablaDD)

    tablaDD = add_artif(filasD, tablaDD, indicescol, indicesfila)
    enc = add_art_enc(filasD, enc, indicescol)
    filasD =  len(tablaDD[:, 0])
    columD = len(tablaDD[0, :])
    tablainvD = np.zeros((filasD,columD))
    print(enc)
    print(tablainvD)

    print(tablaDD)

    cont = 0
    colum_pivote = 0
    fila_pivot = 0
    continuarD = 1

    #while cont < 3: #Esto solo es por pruebas, solo para visualizar las primeras 3 iteraciones..
    while continuarD == 1:
        print(tabulate(tablaDD, headers=enc, tablefmt="fancy_grid")) #Visualizando las iteraciones de la matriz
        columpiv(tablaDD, columD, filasD)
        epivote = pivote(tablaDD, columD, filasD, lista)
        print(colum_pivote)
        print(epivote) #Para poder visualizar el elemento pivote encontrado
        evaluando(tablainvD, tablaDD, columD, epivote)
        inv(tablainvD, tablaDD, columD, filasD)
        continuarD = negativos(tablaDD, columD, filasD) #Si aún hay un negativo dentro de la matriz, se debe continuar

        for i in range(filasD):
            for j in range(columD):
                tablaDD[i,j]=tablainvD[i,j]
        for i in range(filasD):
            for j in range(columD):
                tablainvD[i,j]= None
        cont = cont + 1

    print(tabulate(tablaDD, headers=enc, tablefmt="fancy_grid")) #Visualizando la ultima iteracion de la matriz

    print("Problema dual: ")
    soldual = solucion(decision, columD, filasD, tablaDD, enc)

    return tabla, tablaDD, soldual, solprimal